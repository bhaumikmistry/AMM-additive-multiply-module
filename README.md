# AMM-additive-multiply-module
ADDITIVE MULTIPLY MODULE VHDL implementation.

Abstract : Task was to build and simulate the 4x2 AMM module , 8x8 AMM module with latches and N x N AMM 
using VHDL as the description language on the Altera design environment as the simulation tool and simulate 
its functionality. The task is successfully completed using varieties of modules and mathematical equations 
and mainly with ‘generate’ statements, which can be nested to create two-dimensional instance "arrays". 

1.0	Introduction.

The additive multiply modules (AMM) can receive additional addends and add them to the product of the input 
multiplicand and multiplier. A 4-by-2 AMM which can perform the arithmetic operation such as P = A x B + C + D. 
Here A and B are a 4-bit multiplicand and 2-bit multiplier respectively. The product P is of 6 bits since 
4 + 2 = 6. C is of 4 bits, and D is of 2 bits.


 
Figure 2 8*8 multiplication via 4by2 AMM
The array multiplier implemented by 4-by-2 AMMs is presented in Figure 3. As we can see from Figure 1,
the worst case delay for an 4-by-2 AMM is

 
Figure 3 Logical construction of 8*8 multiplication using 4by2 AMM
2.0	Part I Implementation.

Task : Build and simulate the 4x2 AMM module shown in lecture 7 (and in Figure 6) 
using modular Verilog or VHDL as the description language and either the Altera or Xilinx
WebPack design environment as the simulation tool.  Then, using multiple instantiations of 
this module, build the 8x8 multiplier also shown in lecture 7 (and in Figure 3) and simulate its functionality.  


•	Above, set of images are presented to understand overall schematic and function simulation 
of part I. Which is to generate 8*8 AMM using 4by2 AMM.
•	Figure 11 shows us the delayed o/p. Time bars are showing the delay in the output by an 8by8 AMM.
•	This marks the successful completion of part 1 of the project. 
 
3.0	Part 2 Implementation.

Task: Modify the design from part 1 to add the necessary latches for a maximum clock rate
(minimum delay between latch stages).  The latches should also be modular and are external
to the 4x2 AMM.  Show the pipelined nature of the latched operation using the simulation tool.


 

Figure 12 RTL block of latch to hold AMM output.



 


Figure 13 Latch output per cycle



 

Figure 14 8by8 AMM having a latch after every AMM except last two AMMs.






 
Figure 15 Zoom section of figure_14.


 
Figure 16 Zoom section of figure 14.

•	As we see, Figure 15 and figure 16 gives us the zoomed view of 8by8 AMM using 4by2 AMM and latches attached to it.
•	The last two AMMs will not have any latches attached to it.

 
Figure 17 Waveform simulation of 8by8 AMM ith latches attached.

•	As shown in figure 17, the pipelined view of the out put of the AMM can be easily determined.
•	There are four Latches, which contribute to P (output), hence we can see the signal P changes its value after almost one cycle till the out put is collected at last AMM. 
•	The change in P values indicates that the latches are holding the output of the AMMs till the end of the current clock cycle.
•	This proves the successful completion of part 2. 
4.0	Part 3 Implimentation.

Task: Modify the design from part 2 to allow the user (prior to synthesis – using a generic is allowable) to set the size of the multiplier, i.e. NxN instead of a fixed 8x8.  This modified design should instantiate all of the necessary 4x2 AMMs and latches to successfully complete this operation.  The user should only have to modify the one constant N and then run synthesis for the design to function.


CASE I : GENERIC (N := 8)


 

Figure 18 Section of code showing N:=8.

 


•	After multiple iteration, it came to my attention that falling in the trap to deal with one additional signal (AMM to latch) while iterating two for..generate loop, it will create additional use of signals in N bit loop which needs to be updated after every iteration.
•	I came to a conclusion to make a different block with one AMM + Latch, which takes x y c d and a clock as input and gives o/p tp.

 
Figure 19 Newly generated RTl block.

•	Each above mentioned block is generated by nested for loops.
•	The value of N can only be multiple of 4.
Math: (N>4 and ((N mod 4)=0))

 

Figure 20 Report after N=8 synthesis


 

Figure 21 Automated Generation of 8 block by the algorithm after synthesis.
 

Figure 22 Zoom section of figure 21

 

Figure 23 Zoom section of figure 21.

 

Figure 24 worst cases TCO

 

Figure 25 TCO from clock to each o/p bit. 
 
Figure 26 Waveform simulation of N=8 module.

•	As we have seen in the part 2 of our project, which is manually generated block 8by8 AMM suing 4by2 AMMs and latches had similar delay and similar output pattern.
•	There are four latches which contribute to the output directly and the pair of AMM gives out the o/p signal p.

 


CASE I : GENERIC (N := 16)

•	The value of N can only be multiple of 4.
Math: (N>4 and ((N mod 4)=0))


 
Figure 27 Section of code showing N:=16.


 
Figure 28 Automated generated RTL block for N=16.
 


Figure 29 Zoomed section of o/p p.


 


Figure 30 Report N=16


 

Figure 31 Waveform simulation with N=16.

 

CASE I : GENERIC (N := 32)

 

Figure 32 Section of code showing N:=8.



 

Figure 33 automated generated RTL block for N=32.

 
Figure 34 Zoomed section of above figure with o/p P with the range.


 
Figure 35 report for N=32.



 
Figure 36 Waveform simulation for N=32.


 
Explanation of N by N AMM.

•	Using For generate statement simplifies the creation of new required AMMs depending on the generic N.
•	I have created two constant r and c, which serves as the number of rows and the number of columns.
•	Let us see this generation as a matrix of size r * c, i.e. (N/4) * (N/2).
•	The row value is N/4, because each 4by2 takes 4 bits of vector x similarly column value is N/2, because each 4ny2 takes 2 bits of vector y. 
•	For instance, to understand the former point, we will consider N = 8.  We know that the 8by8 AMM consists of 8 4by2 AMMs. Which, according to our formula, r=2 and c=4. This makes a matrix of 2by4 AMMs. 

	[ 4by2 ] – [ 4by2 ]
	[ 4by2 ] – [ 4by2 ]
	[ 4by2 ] – [ 4by2 ]
	[ 4by2 ] – [ 4by2 ]

•	As the above point and structure explains the automated algorithm. For N=16 it will create a structure of  4 X 8 AMMs. 
•	Using the { for i in 1 to r generate and for j in 1 to c generate } we can select and interconnect the value of  vector x y c d and p. 
•	I have determined five different types of input and output combinations for AMMs. Which are distinguished by the position of the block.
•	For instance we will consider N= 16,

	[     I      ] – [      I    ] - [      I    ] –  [     I     ]
	[   III     ] – [     V    ] - [     V    ] –  [    II     ]
	[   III     ] – [     V    ] - [     V    ] –  [    II     ]
	[   III     ] – [     V    ] - [     V    ] –  [    II     ]
	[   III     ] – [     V    ] - [     V    ] –  [    II     ]
	[   III     ] – [     V    ] - [     V    ] –  [    II     ]
	[   III     ] – [     V    ] - [     V    ] –  [    II     ]
	[   IV     ] – [    IV    ] - [   IV    ] –  [    II     ]


•	As shown in above structure, there are main five types of different blocks and some of them have subtypes considering the required input and required output pins.
•	Type V: Most simplest  because of the position of the block.
1.	D gets pins from previous P
2.	CL  gets pins from above block
3.	CH gets pins from diagonal block.
•	Type I: simplest as it only consists x ,d and y as input and all the c values are zeros.
•	Type III:  The last column starting from right to left. Which does not have any diagonal block for c input.
•	Type II: which has no D input but c as others and addition to these Inputs it feeds the 1st and 0th bit to P.
•	Type IV: similar to type II it gives output to p but four and six bits respectively.

This approach clearly gives output with out any error, this method took a lot of math calculation regarding the interconnection of P to C and D. But I have successfully synthesized the algorithm for N= 8,16, and 32.
